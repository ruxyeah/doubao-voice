# 豆包实时语音 API - 生产级优化指南

## 目录

1. [架构优化](#1-架构优化)
2. [用户与会话管理](#2-用户与会话管理)
3. [连接池与资源管理](#3-连接池与资源管理)
4. [性能优化](#4-性能优化)
5. [安全性增强](#5-安全性增强)
6. [可观测性](#6-可观测性)
7. [高可用与容错](#7-高可用与容错)
8. [成本优化](#8-成本优化)

---

## 1. 架构优化

### 1.1 推荐的生产架构

```
                                    ┌─────────────────┐
                                    │   负载均衡器    │
                                    │  (Nginx/K8s)   │
                                    └────────┬────────┘
                                             │
              ┌──────────────────────────────┼──────────────────────────────┐
              │                              │                              │
              ▼                              ▼                              ▼
    ┌─────────────────┐            ┌─────────────────┐            ┌─────────────────┐
    │  API 服务实例 1  │            │  API 服务实例 2  │            │  API 服务实例 N  │
    └────────┬────────┘            └────────┬────────┘            └────────┬────────┘
             │                              │                              │
             └──────────────────────────────┼──────────────────────────────┘
                                            │
              ┌─────────────────────────────┼─────────────────────────────┐
              │                             │                             │
              ▼                             ▼                             ▼
    ┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
    │     Redis       │           │    PostgreSQL   │           │   消息队列       │
    │   (会话缓存)     │           │   (持久化存储)   │           │  (Kafka/RMQ)    │
    └─────────────────┘           └─────────────────┘           └─────────────────┘
```

### 1.2 服务分层建议

```
┌─────────────────────────────────────────────────────────────────┐
│                         API Gateway                              │
│              (认证、限流、路由、日志)                              │
├─────────────────────────────────────────────────────────────────┤
│                       业务服务层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 用户服务      │  │ 会话服务      │  │ 计费服务      │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│                       语音服务层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 豆包连接管理   │  │ 音频处理      │  │ 协议编解码    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│                       基础设施层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Redis        │  │ PostgreSQL   │  │ 监控告警      │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 用户与会话管理

### 2.1 用户-会话关系模型

```java
/**
 * 用户实体
 */
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String passwordHash;

    // API 配额
    private Integer dailyQuota = 1000;      // 每日调用次数限制
    private Integer monthlyMinutes = 600;   // 每月语音分钟数

    // 用户偏好设置
    @Embedded
    private UserPreferences preferences;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<VoiceSession> sessions;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

/**
 * 用户偏好设置
 */
@Embeddable
public class UserPreferences {
    private String defaultSpeaker = "zh_female_vv_jupiter_bigtts";
    private String defaultBotName = "豆包";
    private String defaultSystemRole;
    private String defaultModel = "O";
    private Boolean enableWebSearch = false;
}
```

### 2.2 会话持久化模型

```java
/**
 * 语音会话实体（持久化）
 */
@Entity
@Table(name = "voice_sessions", indexes = {
    @Index(name = "idx_user_id", columnList = "user_id"),
    @Index(name = "idx_created_at", columnList = "createdAt"),
    @Index(name = "idx_state", columnList = "state")
})
public class VoiceSessionEntity {
    @Id
    private String sessionId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    private SessionState state;

    private String dialogId;

    // 会话配置
    @Embedded
    private SessionConfig config;

    // 统计信息
    private Integer messageCount = 0;
    private Long audioBytesSent = 0L;
    private Long audioBytesReceived = 0L;
    private Long durationMs = 0L;

    // 时间戳
    private LocalDateTime createdAt;
    private LocalDateTime startedAt;
    private LocalDateTime endedAt;
    private LocalDateTime lastActivityAt;

    // 错误信息
    private String errorCode;
    private String errorMessage;
}

/**
 * 对话历史记录
 */
@Entity
@Table(name = "conversation_messages")
public class ConversationMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "session_id")
    private VoiceSessionEntity session;

    @Enumerated(EnumType.STRING)
    private MessageRole role;  // USER, ASSISTANT, SYSTEM

    private String content;
    private String questionId;
    private String replyId;

    private LocalDateTime createdAt;
}
```

### 2.3 会话管理服务优化

```java
/**
 * 生产级会话管理器
 */
@Service
@Slf4j
public class ProductionVoiceSessionManager {

    private final RedisTemplate<String, VoiceSessionCache> redisTemplate;
    private final VoiceSessionRepository sessionRepository;
    private final UserRepository userRepository;
    private final MeterRegistry meterRegistry;

    // Redis 缓存 key 前缀
    private static final String SESSION_CACHE_PREFIX = "voice:session:";
    private static final String USER_SESSIONS_PREFIX = "voice:user:sessions:";

    // 内存中活跃连接（仅存储 WebSocket 连接）
    private final ConcurrentHashMap<String, VoiceSession> activeSessions = new ConcurrentHashMap<>();

    /**
     * 创建会话（关联用户）
     */
    @Transactional
    public VoiceSession createSession(String userId, SessionConfig config) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));

        // 检查用户配额
        checkUserQuota(user);

        // 检查用户并发会话数
        int activeCount = countActiveSessionsByUser(userId);
        if (activeCount >= 3) {
            throw new TooManySessionsException("用户最多同时拥有3个活跃会话");
        }

        String sessionId = UUID.randomUUID().toString();

        // 创建会话实体并持久化
        VoiceSessionEntity entity = new VoiceSessionEntity();
        entity.setSessionId(sessionId);
        entity.setUser(user);
        entity.setState(SessionState.CREATED);
        entity.setConfig(config);
        entity.setCreatedAt(LocalDateTime.now());
        sessionRepository.save(entity);

        // 创建活跃会话
        VoiceSession session = new VoiceSession(sessionId, config, properties);
        activeSessions.put(sessionId, session);

        // 缓存到 Redis
        cacheSession(sessionId, userId, config);

        // 添加到用户会话集合
        addToUserSessions(userId, sessionId);

        // 记录指标
        meterRegistry.counter("voice.session.created", "user", userId).increment();

        log.info("创建会话: sessionId={}, userId={}", sessionId, userId);
        return session;
    }

    /**
     * 获取会话（优先从内存，其次 Redis，最后数据库）
     */
    public Optional<VoiceSession> getSession(String sessionId) {
        // 1. 内存中查找活跃会话
        VoiceSession session = activeSessions.get(sessionId);
        if (session != null) {
            return Optional.of(session);
        }

        // 2. Redis 缓存查找
        VoiceSessionCache cached = redisTemplate.opsForValue()
            .get(SESSION_CACHE_PREFIX + sessionId);
        if (cached != null) {
            // 重建会话（如果需要重连）
            return Optional.of(rebuildSession(cached));
        }

        // 3. 数据库查找（仅返回元数据，不重建连接）
        return sessionRepository.findById(sessionId)
            .map(this::toSessionInfo);
    }

    /**
     * 结束会话
     */
    @Transactional
    public void endSession(String sessionId) {
        VoiceSession session = activeSessions.remove(sessionId);

        if (session != null) {
            try {
                session.endSession();
            } catch (Exception e) {
                log.warn("结束会话时发生错误: {}", e.getMessage());
            }
        }

        // 更新数据库
        sessionRepository.findById(sessionId).ifPresent(entity -> {
            entity.setState(SessionState.ENDED);
            entity.setEndedAt(LocalDateTime.now());
            entity.setDurationMs(calculateDuration(entity));
            sessionRepository.save(entity);
        });

        // 删除 Redis 缓存
        redisTemplate.delete(SESSION_CACHE_PREFIX + sessionId);

        // 从用户会话集合移除
        removeFromUserSessions(sessionId);

        meterRegistry.counter("voice.session.ended").increment();
    }

    /**
     * 获取用户的所有会话
     */
    public List<SessionInfo> getUserSessions(String userId) {
        Set<String> sessionIds = redisTemplate.opsForSet()
            .members(USER_SESSIONS_PREFIX + userId);

        if (sessionIds == null || sessionIds.isEmpty()) {
            // 从数据库加载
            return sessionRepository.findByUserIdOrderByCreatedAtDesc(userId)
                .stream()
                .map(this::toSessionInfo)
                .collect(Collectors.toList());
        }

        return sessionIds.stream()
            .map(this::getSessionInfo)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
    }

    /**
     * 清理过期会话
     */
    @Scheduled(fixedRate = 60000) // 每分钟执行
    public void cleanupExpiredSessions() {
        LocalDateTime threshold = LocalDateTime.now()
            .minus(properties.getSession().getTimeout(), ChronoUnit.MILLIS);

        activeSessions.forEach((sessionId, session) -> {
            if (session.getLastActivityAt().isBefore(threshold)) {
                log.info("清理过期会话: {}", sessionId);
                endSession(sessionId);
            }
        });
    }

    // Redis 缓存操作
    private void cacheSession(String sessionId, String userId, SessionConfig config) {
        VoiceSessionCache cache = new VoiceSessionCache();
        cache.setSessionId(sessionId);
        cache.setUserId(userId);
        cache.setConfig(config);
        cache.setState(SessionState.CREATED);
        cache.setCreatedAt(LocalDateTime.now());

        redisTemplate.opsForValue().set(
            SESSION_CACHE_PREFIX + sessionId,
            cache,
            Duration.ofHours(24)
        );
    }

    private void addToUserSessions(String userId, String sessionId) {
        redisTemplate.opsForSet().add(USER_SESSIONS_PREFIX + userId, sessionId);
        redisTemplate.expire(USER_SESSIONS_PREFIX + userId, Duration.ofDays(7));
    }
}
```

### 2.4 会话缓存结构（Redis）

```java
/**
 * Redis 会话缓存结构
 */
@Data
public class VoiceSessionCache implements Serializable {
    private String sessionId;
    private String userId;
    private SessionState state;
    private String dialogId;
    private SessionConfig config;
    private LocalDateTime createdAt;
    private LocalDateTime lastActivityAt;

    // 统计信息
    private int messageCount;
    private long audioBytesSent;
    private long audioBytesReceived;
}
```

**Redis 数据结构设计**：

```
# 会话详情（Hash 或 String JSON）
voice:session:{sessionId} -> VoiceSessionCache JSON

# 用户的会话集合（Set）
voice:user:sessions:{userId} -> Set<sessionId>

# 活跃会话计数（用于限流）
voice:user:active:{userId} -> count (with TTL)

# 用户今日调用次数
voice:quota:daily:{userId}:{date} -> count

# 用户本月语音分钟数
voice:quota:monthly:{userId}:{yearMonth} -> minutes
```

---

## 3. 连接池与资源管理

### 3.1 豆包连接池

```java
/**
 * 豆包 WebSocket 连接池
 */
@Component
@Slf4j
public class DoubaoConnectionPool {

    private final DoubaoProperties properties;
    private final BlockingQueue<DoubaoWebSocketClient> idleConnections;
    private final Set<DoubaoWebSocketClient> activeConnections;
    private final ScheduledExecutorService scheduler;

    // 连接池配置
    private final int minIdle = 5;
    private final int maxTotal = 100;
    private final long maxWaitMs = 5000;
    private final long idleTimeoutMs = 300000; // 5分钟

    @PostConstruct
    public void init() {
        // 预热连接
        for (int i = 0; i < minIdle; i++) {
            try {
                idleConnections.offer(createConnection());
            } catch (Exception e) {
                log.warn("预热连接失败: {}", e.getMessage());
            }
        }

        // 定期清理空闲连接
        scheduler.scheduleAtFixedRate(this::cleanupIdleConnections,
            60, 60, TimeUnit.SECONDS);

        // 定期补充连接
        scheduler.scheduleAtFixedRate(this::ensureMinIdle,
            30, 30, TimeUnit.SECONDS);
    }

    /**
     * 获取连接
     */
    public DoubaoWebSocketClient borrowConnection() throws Exception {
        DoubaoWebSocketClient client = idleConnections.poll(maxWaitMs, TimeUnit.MILLISECONDS);

        if (client == null) {
            if (activeConnections.size() < maxTotal) {
                client = createConnection();
            } else {
                throw new ConnectionPoolExhaustedException("连接池已满");
            }
        }

        // 验证连接有效性
        if (!client.isConnected()) {
            client = createConnection();
        }

        activeConnections.add(client);
        return client;
    }

    /**
     * 归还连接
     */
    public void returnConnection(DoubaoWebSocketClient client) {
        activeConnections.remove(client);

        if (client.isConnected() && idleConnections.size() < minIdle * 2) {
            idleConnections.offer(client);
        } else {
            closeConnection(client);
        }
    }

    /**
     * 销毁连接（出错时）
     */
    public void destroyConnection(DoubaoWebSocketClient client) {
        activeConnections.remove(client);
        closeConnection(client);
    }

    private DoubaoWebSocketClient createConnection() {
        DoubaoWebSocketClient client = new DoubaoWebSocketClient(properties);
        client.connect();
        // 等待连接就绪
        waitForConnection(client, 10000);
        return client;
    }
}
```

### 3.2 OkHttp 客户端优化

```java
/**
 * 优化的 OkHttp 客户端配置
 */
@Configuration
public class OkHttpConfig {

    @Bean
    public OkHttpClient okHttpClient() {
        // 连接池配置
        ConnectionPool connectionPool = new ConnectionPool(
            50,              // 最大空闲连接数
            5, TimeUnit.MINUTES  // 空闲连接存活时间
        );

        // 调度器配置
        Dispatcher dispatcher = new Dispatcher();
        dispatcher.setMaxRequests(200);           // 最大并发请求数
        dispatcher.setMaxRequestsPerHost(50);     // 每个主机最大并发数

        return new OkHttpClient.Builder()
            .connectionPool(connectionPool)
            .dispatcher(dispatcher)
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(10, TimeUnit.SECONDS)
            .pingInterval(30, TimeUnit.SECONDS)   // WebSocket 心跳
            .retryOnConnectionFailure(true)
            .build();
    }
}
```

### 3.3 线程池配置

```java
/**
 * 线程池配置
 */
@Configuration
public class ThreadPoolConfig {

    /**
     * 音频处理线程池
     */
    @Bean("audioProcessorExecutor")
    public ExecutorService audioProcessorExecutor() {
        return new ThreadPoolExecutor(
            10,                      // 核心线程数
            50,                      // 最大线程数
            60L, TimeUnit.SECONDS,   // 空闲线程存活时间
            new LinkedBlockingQueue<>(1000),  // 队列容量
            new ThreadFactoryBuilder()
                .setNameFormat("audio-processor-%d")
                .setDaemon(true)
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
        );
    }

    /**
     * WebSocket 消息处理线程池
     */
    @Bean("wsMessageExecutor")
    public ExecutorService wsMessageExecutor() {
        return new ThreadPoolExecutor(
            20,
            100,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(5000),
            new ThreadFactoryBuilder()
                .setNameFormat("ws-message-%d")
                .setDaemon(true)
                .build(),
            new ThreadPoolExecutor.AbortPolicy()
        );
    }
}
```

---

## 4. 性能优化

### 4.1 音频数据零拷贝

```java
/**
 * 使用 ByteBuffer 减少内存拷贝
 */
public class OptimizedAudioProcessor {

    // 使用直接内存缓冲区
    private final ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);

    /**
     * 零拷贝音频处理
     */
    public ByteBuffer processAudio(ByteBuffer input) {
        directBuffer.clear();

        // 直接在 ByteBuffer 上操作，避免 byte[] 拷贝
        while (input.hasRemaining()) {
            short sample = input.getShort();
            // 处理音频样本
            directBuffer.putShort(sample);
        }

        directBuffer.flip();
        return directBuffer;
    }
}
```

### 4.2 消息批量处理

```java
/**
 * 音频消息批量发送
 */
public class BatchAudioSender {

    private final BlockingQueue<byte[]> audioQueue = new LinkedBlockingQueue<>();
    private final ScheduledExecutorService scheduler;
    private final int batchSize = 5;
    private final long flushIntervalMs = 100;

    @PostConstruct
    public void init() {
        scheduler.scheduleAtFixedRate(this::flushBatch,
            flushIntervalMs, flushIntervalMs, TimeUnit.MILLISECONDS);
    }

    /**
     * 添加音频数据到队列
     */
    public void addAudio(byte[] audioData) {
        audioQueue.offer(audioData);

        // 达到批量大小立即发送
        if (audioQueue.size() >= batchSize) {
            flushBatch();
        }
    }

    /**
     * 批量发送
     */
    private synchronized void flushBatch() {
        if (audioQueue.isEmpty()) return;

        List<byte[]> batch = new ArrayList<>();
        audioQueue.drainTo(batch, batchSize);

        if (!batch.isEmpty()) {
            // 合并音频数据
            byte[] merged = mergeAudioData(batch);
            // 发送
            sendToDoubao(merged);
        }
    }
}
```

### 4.3 响应压缩

```java
/**
 * 启用 Gzip 响应压缩
 */
@Configuration
public class CompressionConfig {

    @Bean
    public FilterRegistrationBean<Filter> compressionFilter() {
        FilterRegistrationBean<Filter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new OncePerRequestFilter() {
            @Override
            protected void doFilterInternal(HttpServletRequest request,
                    HttpServletResponse response, FilterChain chain)
                    throws ServletException, IOException {

                // 检查是否支持 gzip
                String encoding = request.getHeader("Accept-Encoding");
                if (encoding != null && encoding.contains("gzip")) {
                    GzipResponseWrapper wrapper = new GzipResponseWrapper(response);
                    chain.doFilter(request, wrapper);
                    wrapper.finish();
                } else {
                    chain.doFilter(request, response);
                }
            }
        });
        registration.addUrlPatterns("/api/*");
        return registration;
    }
}
```

### 4.4 WebSocket 消息序列化优化

```java
/**
 * 使用 Jackson 对象池减少 GC
 */
@Component
public class OptimizedJsonSerializer {

    private final ObjectMapper objectMapper;
    private final ObjectPool<JsonGenerator> generatorPool;
    private final ObjectPool<JsonParser> parserPool;

    public OptimizedJsonSerializer(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;

        // 创建 JsonGenerator 对象池
        this.generatorPool = new GenericObjectPool<>(
            new BasePooledObjectFactory<>() {
                @Override
                public JsonGenerator create() throws Exception {
                    return objectMapper.getFactory()
                        .createGenerator(new ByteArrayOutputStream());
                }

                @Override
                public PooledObject<JsonGenerator> wrap(JsonGenerator obj) {
                    return new DefaultPooledObject<>(obj);
                }
            }
        );
    }

    /**
     * 高效序列化
     */
    public byte[] serialize(Object obj) throws Exception {
        JsonGenerator generator = generatorPool.borrowObject();
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            generator.setCodec(objectMapper);
            // ... 序列化
            return baos.toByteArray();
        } finally {
            generatorPool.returnObject(generator);
        }
    }
}
```

---

## 5. 安全性增强

### 5.1 认证与授权

```java
/**
 * JWT 认证过滤器
 */
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        String token = extractToken(request);

        if (token != null && tokenProvider.validateToken(token)) {
            String userId = tokenProvider.getUserIdFromToken(token);
            User user = userService.loadUserById(userId);

            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                    user, null, user.getAuthorities());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        chain.doFilter(request, response);
    }
}

/**
 * WebSocket 握手认证
 */
@Component
public class WebSocketAuthInterceptor implements HandshakeInterceptor {

    private final JwtTokenProvider tokenProvider;

    @Override
    public boolean beforeHandshake(ServerHttpRequest request,
            ServerHttpResponse response, WebSocketHandler wsHandler,
            Map<String, Object> attributes) throws Exception {

        // 从 URL 参数获取 token
        String token = extractTokenFromQuery(request);

        if (token == null || !tokenProvider.validateToken(token)) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return false;
        }

        String userId = tokenProvider.getUserIdFromToken(token);
        attributes.put("userId", userId);

        return true;
    }
}
```

### 5.2 API 限流

```java
/**
 * 基于 Redis 的分布式限流
 */
@Component
public class RateLimiter {

    private final RedisTemplate<String, String> redisTemplate;

    // 限流配置
    private final int requestsPerSecond = 10;
    private final int requestsPerMinute = 100;
    private final int requestsPerDay = 10000;

    /**
     * 检查是否超过限流
     */
    public boolean isAllowed(String userId, String action) {
        String key = String.format("ratelimit:%s:%s", userId, action);

        // 使用 Redis Lua 脚本实现原子操作
        String script = """
            local key = KEYS[1]
            local limit = tonumber(ARGV[1])
            local window = tonumber(ARGV[2])

            local current = redis.call('GET', key)
            if current and tonumber(current) >= limit then
                return 0
            end

            current = redis.call('INCR', key)
            if current == 1 then
                redis.call('EXPIRE', key, window)
            end

            return 1
            """;

        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            List.of(key + ":second"),
            String.valueOf(requestsPerSecond),
            "1"
        );

        return result != null && result == 1;
    }

    /**
     * 获取剩余配额
     */
    public RateLimitInfo getRateLimitInfo(String userId) {
        // ... 查询各维度剩余配额
    }
}

/**
 * 限流拦截器
 */
@Component
public class RateLimitInterceptor implements HandlerInterceptor {

    private final RateLimiter rateLimiter;

    @Override
    public boolean preHandle(HttpServletRequest request,
            HttpServletResponse response, Object handler) throws Exception {

        String userId = getCurrentUserId();
        String action = request.getRequestURI();

        if (!rateLimiter.isAllowed(userId, action)) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.setHeader("Retry-After", "1");
            response.getWriter().write("{\"error\":\"请求过于频繁，请稍后重试\"}");
            return false;
        }

        // 添加限流信息到响应头
        RateLimitInfo info = rateLimiter.getRateLimitInfo(userId);
        response.setHeader("X-RateLimit-Limit", String.valueOf(info.getLimit()));
        response.setHeader("X-RateLimit-Remaining", String.valueOf(info.getRemaining()));
        response.setHeader("X-RateLimit-Reset", String.valueOf(info.getResetTime()));

        return true;
    }
}
```

### 5.3 输入验证与清理

```java
/**
 * 输入验证服务
 */
@Service
public class InputValidationService {

    // 敏感词过滤
    private final SensitiveWordFilter sensitiveWordFilter;

    // 最大文本长度
    private final int maxTextLength = 1000;

    /**
     * 验证文本输入
     */
    public ValidationResult validateTextInput(String text) {
        if (text == null || text.isBlank()) {
            return ValidationResult.error("文本不能为空");
        }

        if (text.length() > maxTextLength) {
            return ValidationResult.error("文本长度不能超过 " + maxTextLength);
        }

        // 清理 HTML 标签
        text = Jsoup.clean(text, Whitelist.none());

        // 敏感词检测
        List<String> sensitiveWords = sensitiveWordFilter.findAll(text);
        if (!sensitiveWords.isEmpty()) {
            return ValidationResult.error("包含敏感词汇");
        }

        return ValidationResult.success(text);
    }

    /**
     * 验证会话配置
     */
    public ValidationResult validateSessionConfig(SessionConfig config) {
        // 验证音色
        if (!isValidSpeaker(config.getSpeaker())) {
            return ValidationResult.error("无效的音色");
        }

        // 验证模型
        if (!isValidModel(config.getModel())) {
            return ValidationResult.error("无效的模型");
        }

        // 验证系统角色设定长度
        if (config.getSystemRole() != null &&
            config.getSystemRole().length() > 2000) {
            return ValidationResult.error("系统角色设定过长");
        }

        return ValidationResult.success();
    }
}
```

### 5.4 凭证安全管理

```yaml
# application-prod.yml
doubao:
  api:
    # 使用 Vault 或 AWS Secrets Manager
    app-id: ${VAULT_DOUBAO_APP_ID}
    access-key: ${VAULT_DOUBAO_ACCESS_KEY}

# 或使用 Spring Cloud Config 加密
spring:
  cloud:
    config:
      server:
        encrypt:
          enabled: true
```

```java
/**
 * 凭证轮换服务
 */
@Service
public class CredentialRotationService {

    private final VaultTemplate vaultTemplate;
    private final AtomicReference<Credentials> currentCredentials;

    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨 2 点
    public void rotateCredentials() {
        // 从 Vault 获取新凭证
        VaultResponse response = vaultTemplate.read("secret/doubao");

        Credentials newCredentials = new Credentials(
            response.getData().get("appId").toString(),
            response.getData().get("accessKey").toString()
        );

        currentCredentials.set(newCredentials);
        log.info("凭证已轮换");
    }
}
```

---

## 6. 可观测性

### 6.1 指标收集 (Metrics)

```java
/**
 * 自定义指标
 */
@Component
public class VoiceMetrics {

    private final MeterRegistry registry;

    // 计数器
    private final Counter sessionCreatedCounter;
    private final Counter sessionErrorCounter;
    private final Counter audioBytesSentCounter;
    private final Counter audioBytesReceivedCounter;

    // 计时器
    private final Timer sessionDurationTimer;
    private final Timer asrLatencyTimer;
    private final Timer ttsLatencyTimer;

    // 仪表
    private final AtomicInteger activeSessionsGauge;
    private final AtomicInteger activeConnectionsGauge;

    public VoiceMetrics(MeterRegistry registry) {
        this.registry = registry;

        // 会话计数
        this.sessionCreatedCounter = Counter.builder("voice.session.created")
            .description("创建的会话总数")
            .register(registry);

        this.sessionErrorCounter = Counter.builder("voice.session.errors")
            .description("会话错误总数")
            .tag("type", "unknown")
            .register(registry);

        // 音频字节数
        this.audioBytesSentCounter = Counter.builder("voice.audio.bytes.sent")
            .description("发送的音频字节数")
            .register(registry);

        // 会话时长分布
        this.sessionDurationTimer = Timer.builder("voice.session.duration")
            .description("会话时长")
            .publishPercentiles(0.5, 0.9, 0.99)
            .register(registry);

        // ASR 延迟
        this.asrLatencyTimer = Timer.builder("voice.asr.latency")
            .description("语音识别延迟")
            .publishPercentiles(0.5, 0.9, 0.99)
            .register(registry);

        // 活跃会话数
        this.activeSessionsGauge = registry.gauge("voice.sessions.active",
            new AtomicInteger(0));
    }

    public void recordSessionCreated(String userId) {
        sessionCreatedCounter.increment();
        activeSessionsGauge.incrementAndGet();
    }

    public void recordSessionEnded(long durationMs) {
        activeSessionsGauge.decrementAndGet();
        sessionDurationTimer.record(durationMs, TimeUnit.MILLISECONDS);
    }

    public void recordAsrLatency(long latencyMs) {
        asrLatencyTimer.record(latencyMs, TimeUnit.MILLISECONDS);
    }

    public void recordError(String errorType) {
        Counter.builder("voice.session.errors")
            .tag("type", errorType)
            .register(registry)
            .increment();
    }
}
```

### 6.2 分布式追踪

```java
/**
 * 追踪配置
 */
@Configuration
public class TracingConfig {

    @Bean
    public Tracer tracer() {
        return GlobalTracer.get();
    }
}

/**
 * WebSocket 追踪
 */
@Component
public class TracedWebSocketHandler extends VoiceWebSocketHandler {

    private final Tracer tracer;

    @Override
    public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) {
        Span span = tracer.buildSpan("websocket.message")
            .withTag("session.id", getSessionId(session))
            .withTag("message.type", getMessageType(message))
            .start();

        try (Scope scope = tracer.activateSpan(span)) {
            super.handleMessage(session, message);
        } catch (Exception e) {
            span.setTag("error", true);
            span.log(Map.of("error.message", e.getMessage()));
            throw e;
        } finally {
            span.finish();
        }
    }
}
```

### 6.3 结构化日志

```java
/**
 * 日志增强
 */
@Aspect
@Component
public class LoggingAspect {

    @Around("@annotation(Logged)")
    public Object logMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        // 结构化日志
        MDC.put("method", methodName);
        MDC.put("class", className);
        MDC.put("traceId", getTraceId());

        long startTime = System.currentTimeMillis();

        try {
            Object result = joinPoint.proceed();

            log.info("方法执行成功",
                kv("duration_ms", System.currentTimeMillis() - startTime),
                kv("result_type", result != null ? result.getClass().getSimpleName() : "null")
            );

            return result;
        } catch (Exception e) {
            log.error("方法执行失败",
                kv("duration_ms", System.currentTimeMillis() - startTime),
                kv("error", e.getMessage()),
                e
            );
            throw e;
        } finally {
            MDC.clear();
        }
    }
}
```

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="JSON" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyName>traceId</includeMdcKeyName>
            <includeMdcKeyName>sessionId</includeMdcKeyName>
            <includeMdcKeyName>userId</includeMdcKeyName>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="JSON" />
    </root>
</configuration>
```

### 6.4 健康检查

```java
/**
 * 自定义健康检查
 */
@Component
public class DoubaoHealthIndicator implements HealthIndicator {

    private final DoubaoConnectionPool connectionPool;
    private final AtomicLong lastSuccessfulConnection = new AtomicLong();

    @Override
    public Health health() {
        try {
            // 检查连接池
            int activeConnections = connectionPool.getActiveCount();
            int idleConnections = connectionPool.getIdleCount();

            // 尝试创建测试连接
            boolean canConnect = testConnection();

            if (canConnect) {
                lastSuccessfulConnection.set(System.currentTimeMillis());
                return Health.up()
                    .withDetail("activeConnections", activeConnections)
                    .withDetail("idleConnections", idleConnections)
                    .withDetail("lastSuccessfulConnection", lastSuccessfulConnection.get())
                    .build();
            } else {
                return Health.down()
                    .withDetail("reason", "无法连接豆包API")
                    .withDetail("lastSuccessfulConnection", lastSuccessfulConnection.get())
                    .build();
            }
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }

    private boolean testConnection() {
        // 实现连接测试逻辑
        return true;
    }
}
```

---

## 7. 高可用与容错

### 7.1 断线重连

```java
/**
 * 自动重连的 WebSocket 客户端
 */
public class ResilientDoubaoClient {

    private final DoubaoProperties properties;
    private final ScheduledExecutorService scheduler;

    private volatile DoubaoWebSocketClient client;
    private volatile boolean shouldReconnect = true;

    // 重连配置
    private final int maxRetries = 5;
    private final long initialDelayMs = 1000;
    private final long maxDelayMs = 30000;
    private final double multiplier = 2.0;

    private AtomicInteger retryCount = new AtomicInteger(0);

    /**
     * 连接（带自动重连）
     */
    public void connect() {
        try {
            client = new DoubaoWebSocketClient(properties);
            client.addListener(new ReconnectListener());
            client.connect();
            retryCount.set(0);
        } catch (Exception e) {
            scheduleReconnect();
        }
    }

    /**
     * 重连监听器
     */
    private class ReconnectListener implements DoubaoClientListener {
        @Override
        public void onDisconnected(int code, String reason) {
            if (shouldReconnect && code != 1000) {
                scheduleReconnect();
            }
        }

        @Override
        public void onError(Throwable error) {
            if (shouldReconnect) {
                scheduleReconnect();
            }
        }
    }

    /**
     * 指数退避重连
     */
    private void scheduleReconnect() {
        int currentRetry = retryCount.incrementAndGet();

        if (currentRetry > maxRetries) {
            log.error("重连次数超过最大限制，放弃重连");
            notifyConnectionFailed();
            return;
        }

        // 计算延迟（指数退避 + 抖动）
        long delay = Math.min(
            (long) (initialDelayMs * Math.pow(multiplier, currentRetry - 1)),
            maxDelayMs
        );
        delay += ThreadLocalRandom.current().nextLong(delay / 4); // 添加抖动

        log.info("将在 {}ms 后进行第 {} 次重连", delay, currentRetry);

        scheduler.schedule(() -> {
            if (shouldReconnect) {
                connect();
            }
        }, delay, TimeUnit.MILLISECONDS);
    }

    /**
     * 优雅关闭
     */
    public void shutdown() {
        shouldReconnect = false;
        if (client != null) {
            client.disconnect();
        }
    }
}
```

### 7.2 熔断器模式

```java
/**
 * 使用 Resilience4j 实现熔断
 */
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public CircuitBreaker doubaoCircuitBreaker() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)           // 失败率阈值 50%
            .waitDurationInOpenState(Duration.ofSeconds(30))  // 熔断时间
            .slidingWindowSize(10)              // 滑动窗口大小
            .minimumNumberOfCalls(5)            // 最小调用次数
            .permittedNumberOfCallsInHalfOpenState(3)  // 半开状态允许的调用次数
            .recordExceptions(IOException.class, TimeoutException.class)
            .build();

        return CircuitBreaker.of("doubao", config);
    }
}

/**
 * 带熔断的会话服务
 */
@Service
public class ResilientVoiceService {

    private final CircuitBreaker circuitBreaker;
    private final VoiceService voiceService;

    public VoiceSession createSession(SessionConfig config) {
        return circuitBreaker.executeSupplier(() ->
            voiceService.createSession(config)
        );
    }

    /**
     * 带降级的创建会话
     */
    public VoiceSession createSessionWithFallback(SessionConfig config) {
        return Try.ofSupplier(
            CircuitBreaker.decorateSupplier(circuitBreaker,
                () -> voiceService.createSession(config))
        ).recover(throwable -> {
            // 降级处理：返回离线模式或排队
            log.warn("创建会话失败，进入降级模式: {}", throwable.getMessage());
            return createOfflineSession(config);
        }).get();
    }
}
```

### 7.3 请求超时与取消

```java
/**
 * 带超时控制的操作
 */
@Service
public class TimeoutAwareVoiceService {

    private final ExecutorService executor;

    /**
     * 带超时的发送消息
     */
    public CompletableFuture<Void> sendMessageWithTimeout(
            String sessionId, Object message, long timeoutMs) {

        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            sendMessage(sessionId, message);
        }, executor);

        return future.orTimeout(timeoutMs, TimeUnit.MILLISECONDS)
            .exceptionally(ex -> {
                if (ex instanceof TimeoutException) {
                    log.warn("发送消息超时: sessionId={}", sessionId);
                    // 取消操作
                    cancelPendingMessage(sessionId);
                }
                throw new RuntimeException(ex);
            });
    }
}
```

### 7.4 多实例会话同步

```java
/**
 * 使用 Redis Pub/Sub 同步会话状态
 */
@Component
public class SessionSyncService {

    private final RedisTemplate<String, String> redisTemplate;
    private final VoiceSessionManager sessionManager;

    private static final String SESSION_CHANNEL = "voice:session:events";

    @PostConstruct
    public void init() {
        // 订阅会话事件
        redisTemplate.getConnectionFactory().getConnection()
            .subscribe((message, pattern) -> {
                handleSessionEvent(message);
            }, SESSION_CHANNEL.getBytes());
    }

    /**
     * 发布会话事件
     */
    public void publishSessionEvent(SessionEvent event) {
        String message = serialize(event);
        redisTemplate.convertAndSend(SESSION_CHANNEL, message);
    }

    /**
     * 处理会话事件
     */
    private void handleSessionEvent(Message message) {
        SessionEvent event = deserialize(new String(message.getBody()));

        switch (event.getType()) {
            case SESSION_ENDED:
                // 如果其他实例结束了会话，本地也要清理
                sessionManager.localCleanup(event.getSessionId());
                break;
            case SESSION_TRANSFERRED:
                // 会话转移到其他实例
                sessionManager.releaseSession(event.getSessionId());
                break;
        }
    }
}
```

---

## 8. 成本优化

### 8.1 使用量统计与计费

```java
/**
 * 使用量统计服务
 */
@Service
public class UsageTrackingService {

    private final RedisTemplate<String, String> redisTemplate;
    private final UsageRepository usageRepository;

    /**
     * 记录音频使用量
     */
    public void recordAudioUsage(String userId, String sessionId,
            long bytesSent, long bytesReceived, long durationMs) {

        String date = LocalDate.now().toString();
        String month = YearMonth.now().toString();

        // 更新 Redis 计数器
        String dailyKey = String.format("usage:%s:%s", userId, date);
        String monthlyKey = String.format("usage:%s:%s", userId, month);

        redisTemplate.opsForHash().increment(dailyKey, "bytesSent", bytesSent);
        redisTemplate.opsForHash().increment(dailyKey, "bytesReceived", bytesReceived);
        redisTemplate.opsForHash().increment(dailyKey, "durationMs", durationMs);
        redisTemplate.opsForHash().increment(dailyKey, "sessionCount", 1);

        redisTemplate.expire(dailyKey, Duration.ofDays(7));

        // 异步持久化到数据库
        asyncSaveUsageRecord(userId, sessionId, bytesSent, bytesReceived, durationMs);
    }

    /**
     * 获取用户使用量统计
     */
    public UsageStats getUserUsageStats(String userId, LocalDate from, LocalDate to) {
        return usageRepository.getAggregatedUsage(userId, from, to);
    }

    /**
     * 检查配额
     */
    public QuotaCheckResult checkQuota(String userId) {
        User user = userRepository.findById(userId).orElseThrow();

        String today = LocalDate.now().toString();
        String month = YearMonth.now().toString();

        // 获取今日使用量
        Long dailyCalls = getLongFromHash("usage:" + userId + ":" + today, "sessionCount");
        Long monthlyMinutes = getLongFromHash("usage:" + userId + ":" + month, "durationMs") / 60000;

        boolean dailyExceeded = dailyCalls >= user.getDailyQuota();
        boolean monthlyExceeded = monthlyMinutes >= user.getMonthlyMinutes();

        return new QuotaCheckResult(
            !dailyExceeded && !monthlyExceeded,
            user.getDailyQuota() - dailyCalls,
            user.getMonthlyMinutes() - monthlyMinutes
        );
    }
}
```

### 8.2 空闲连接回收

```java
/**
 * 智能连接管理
 */
@Component
public class SmartConnectionManager {

    // 低峰期最小连接数
    private final int lowTrafficMinConnections = 2;
    // 高峰期最小连接数
    private final int highTrafficMinConnections = 10;

    /**
     * 根据流量动态调整连接池
     */
    @Scheduled(fixedRate = 60000)
    public void adjustConnectionPool() {
        int hour = LocalTime.now().getHour();
        int activeRequests = getCurrentActiveRequests();

        // 判断是否高峰期 (9:00-22:00)
        boolean isHighTraffic = hour >= 9 && hour <= 22;

        int targetMin = isHighTraffic ? highTrafficMinConnections : lowTrafficMinConnections;

        // 根据实际请求量调整
        if (activeRequests > targetMin * 2) {
            // 扩容
            connectionPool.setMinIdle(Math.min(targetMin * 2, maxConnections));
        } else if (activeRequests < targetMin / 2) {
            // 缩容
            connectionPool.setMinIdle(targetMin);
        }
    }
}
```

### 8.3 音频压缩优化

```java
/**
 * 音频压缩服务
 */
@Service
public class AudioCompressionService {

    /**
     * 检测静音并跳过发送
     */
    public boolean isSilence(byte[] audioData, double threshold) {
        // 计算音频能量
        double energy = calculateEnergy(audioData);
        return energy < threshold;
    }

    /**
     * 音频降采样（在网络较差时）
     */
    public byte[] downsample(byte[] audioData, int fromRate, int toRate) {
        // 从 16kHz 降到 8kHz（节省 50% 带宽）
        // ... 实现降采样逻辑
        return downsampled;
    }

    /**
     * VAD (语音活动检测) - 只发送有声音的片段
     */
    public List<byte[]> extractVoiceSegments(byte[] audioData) {
        // 使用 WebRTC VAD 或其他 VAD 算法
        // ... 实现 VAD 逻辑
        return voiceSegments;
    }
}
```

### 8.4 缓存策略

```java
/**
 * 多级缓存配置
 */
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        // 本地缓存（Caffeine）
        CaffeineCacheManager localCacheManager = new CaffeineCacheManager();
        localCacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
        );

        // Redis 缓存
        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer()))
            )
            .build();

        // 组合缓存（先查本地，再查 Redis）
        return new CompositeCacheManager(localCacheManager, redisCacheManager);
    }
}

/**
 * 缓存使用示例
 */
@Service
public class CachedUserService {

    @Cacheable(value = "users", key = "#userId")
    public User getUserById(String userId) {
        return userRepository.findById(userId).orElseThrow();
    }

    @Cacheable(value = "user-preferences", key = "#userId")
    public UserPreferences getUserPreferences(String userId) {
        return preferencesRepository.findByUserId(userId);
    }

    @CacheEvict(value = {"users", "user-preferences"}, key = "#userId")
    public void updateUser(String userId, UserUpdateRequest request) {
        // ... 更新用户
    }
}
```

---

## 总结

### 核心优化清单

| 领域 | 优化项 | 优先级 | 复杂度 |
|------|--------|--------|--------|
| **架构** | 服务分层 | 高 | 中 |
| **架构** | 读写分离 | 中 | 中 |
| **会话管理** | Redis 缓存 | 高 | 低 |
| **会话管理** | 用户关联 | 高 | 中 |
| **会话管理** | 持久化存储 | 中 | 中 |
| **连接管理** | 连接池 | 高 | 中 |
| **连接管理** | 线程池优化 | 高 | 低 |
| **性能** | 零拷贝 | 中 | 高 |
| **性能** | 批量处理 | 中 | 中 |
| **安全** | JWT 认证 | 高 | 低 |
| **安全** | 限流 | 高 | 中 |
| **安全** | 输入验证 | 高 | 低 |
| **可观测性** | Metrics | 高 | 低 |
| **可观测性** | 分布式追踪 | 中 | 中 |
| **可观测性** | 结构化日志 | 高 | 低 |
| **容错** | 断线重连 | 高 | 中 |
| **容错** | 熔断器 | 中 | 低 |
| **成本** | 使用量统计 | 高 | 中 |
| **成本** | 空闲回收 | 中 | 低 |

### 部署建议

1. **最小生产配置**：2 实例 + Redis + PostgreSQL
2. **标准生产配置**：4 实例 + Redis Cluster + PostgreSQL 主从
3. **高可用配置**：8+ 实例 + Redis Sentinel + PostgreSQL + 消息队列
